#!/bin/sh
# Configuration for interactive shells

export BASH_RC_HAS_RUN=TRUE

export EDITOR=`which vim nano | head -n 1`

# Configure history backlog
export HISTCONTROL=ignoreboth:erasedups
export HISTIGNORE=history:jobs:fg:bg
export HISTSIZE=20000
export HISTTIMEFORMAT='%F %T '

export PAGER=less
export LESS='-iMSx4 -FXR'


# Update history file on every command
if [ -n "${PROMPT_COMMAND%%*history*}" ]; then
  # No history reference found... add it.
  export PROMPT_COMMAND="history -a; ${PROMPT_COMMAND}"
fi

if [ -n "${PYTHON_USERCUSTOM}" ]; then
  mkdir -p "${PYTHON_USERCUSTOM}"
fi


shopt -s checkwinsize
shopt -s cdspell
shopt -s hostcomplete
shopt -s histappend
shopt -s cmdhist
shopt -s histreedit
shopt -s checkhash

# shopt -s mailwarn


# git prompt methods
export GIT_PROMPT="" # start empty
export GIT_PS1_SHOWUPSTREAM=auto
export GIT_PS1_SHOWDIRTYSTATE=true
export GIT_PS1_SHOWSTASHSTATE=true
export GIT_PS1_SHOWUNTRACKEDFILES=true
if [ -f /usr/local/git/contrib/completion/git-prompt.sh ]; then
  . /usr/local/git/contrib/completion/git-prompt.sh
  type __git_ps1 > /dev/null && export GIT_PROMPT='$(__git_ps1 " (%s)")'
fi

# git autocomplete
[ -f /usr/local/git/contrib/completion/git-completion.bash ] && . /usr/local/git/contrib/completion/git-completion.bash


# Other completeion available on the host...
[ -f /etc/bash_completion ] && . /etc/bash_completion
[ -f ~/.bash_aliases ] && source ~/.bash_aliases


# Mark the end of the prompt for SCREEN
__mark_prompt_ending () {
    printf '%bk%s%b%b' \\033 "${@}" \\033 \\0134
}

export PROMPT_NAME="${HOSTNAME%%.*}" # default SCREEN terminal name
printf -v title "" # default hardstatus

abbrev_cwd () {
  echo "${PWD}" | sed -E "s@${HOME}@~@; s@([^/])[^/]*/@\\1/@g;"
}


case $TERM in
  screen*)
    # On remote hosts (i.e. SSH connections) use hostname for prompt name
    [ -z "$SSH_TTY" ] || export PROMPT_NAME="${HOSTNAME%%.*}"; # this is redundant...
    printf -v title "%s" '\[\e]0;\u@\h: `abbrev_cwd`\a\]' # sets hardstatus  with username, host, etc.

    [ -n "${PROMPT_COMMAND}" -a -z "${PROMPT_COMMAND##*;}" ] && semi=";"
    export PROMPT_COMMAND="${PROMPT_COMMAND}${semi} __mark_prompt_ending \${PROMPT_NAME:-shell}"

    export color_prompt=on;
    ;;
  linux|xterm*|gnome*|*color*)
    export color_prompt=on;
    ;;
esac

# Enable color for other shells...
[ -z "$COLORTERM" ] || export color_prompt=on;

# Disable color for non-interactive shells.
[ -z "$PS1" ] && export color_prompt=off;


# Prompt configuration wrapped in method with local vars to prevent littering shell namespace.
__generate_color_prompt () {

    local color_now=36 # cyan
    local color_user=32 # green
    local color_host=33 # yellow
    local color_dir=34 # blue
    local color_chroot=31 # red
    local color_shell=32 # none
    local color_error=33 # yellow
    local color_pass=32 # green

    # username: red, if root or UID=0
    if [ $USER = 'root' ] || [ $UID -eq 0 ]; then
      local color_user=31; # red
      local color_shell=31; # red
    fi

    local bell now user host workdir chroot shell jobs;

    printf -v bell '\[\a\]'
    printf -v now '\[\e[00;%dm\]\\t\[\e[0m\]' $color_now
    printf -v user '\[\e[01;%dm\]\\u\[\e[0m\]' $color_user
    printf -v host '\[\e[01;%dm\]\\h\[\e[0m\]' $color_host
    printf -v workdir '\[\e[01;%dm\]\\W\[\e[0m\]' $color_dir
    printf -v chroot '\[\e[01;%dm\]%s\[\e[0m\]%s' $color_chroot "$ch" "$chroot_trail" # no trailing space
    printf -v shell '\[\e[00;%dm\]\\$\[\e[0m\] ' $color_shell # trailing space
    printf -v jobs '\j' # no formatting

    #local errstat="\$(printf '%.*s' \$? \$?)"

    # Append the return value of the last command to the prompt (red if error)
    local errstat="\[\e[00;\$((\$? ? $color_error : $color_pass ))m\]\$?\[\e[0m\]" # no trailing space


    # Throw it all together
    printf -v PS1 '%s%s%s%s %s@%s %s%s %s %s %s' "$bell" "$title" "$chroot" "$now" "$user" "$host" "$workdir" "${GIT_PROMPT}" "$jobs" "$errstat"  "$shell"

    export PS1;
    export PS2='\[\e[00;33m\]>\[\e[0m\] '
    export PS3='> ' # PS3 doesn't get expanded like 1, 2 and 4
    export PS4='\[\e[01;31m\]+\[\e[0m\]'
    export GIT_PS1_SHOWCOLORHINTS=true

}




case ${color_prompt} in
  on)
    __generate_color_prompt;
    ;;
  *)
    printf -v PS1 '\t \h@\h \W%s \$' "${GIT_PROMPT}";
    export PS1;
    ;;
esac

seldir () {
  [ $# -gt 0 ] && dirs -v | egrep "$@" || dirs -v
  read -p "Directory number: " dirnum
  [ -z "$dirnum" ] || pushd +${dirnum} >/dev/null 2>/dev/null
  echo "#" `pwd`
}

crypto () {
  case $1 in
    encrypt) openssl aes-256-cbc -e -in "${2}" -out "${2}.aes";;
    decrypt) openssl aes-256-cbc -d -in "${2}" -out "${2%.aes}";;
  esac
}

MD5_UTIL=`which md5sum md5`

case $MD5_UTIL in
  *md5) alias md5sum="md5 -r" # BSD (OS X) reverse option for compatibility with Linux
   ;;
esac

git_filechecksums () {
  for filename; do
    git log --format='%h' "${filename}" | while read commit; do
      checksum=`git show ${commit}:${filename} | md5sum | cut -c 1-32`
      printf '%s %s %s\n' "${commit}" "${checksum}" "${filename}"
    done
  done
}

git_md5tree () {
  for treeish; do
    git ls-tree "${treeish}" | while read perms filetype object filename; do
      checksum=`git cat-file ${filetype} ${object} | md5sum | cut -c 1-32`
      printf '%s %s:%s\n' "${checksum}" "${treeish}" "${filename}"
    done
  done
}

git_search_history () {
  git grep "${@}" $(git rev-list --all)
}

find_sublime_project () {
  searchpath="${1:-`pwd`}"
  find ${searchpath} -name '*.sublime-project' | head -n 1
}

load_sublime_path () {
  find_sublime_project "$@" | while read proj; do
    subl -n --project "$proj"
    return 0
  done
  if [ $# -eq 0 ]; then
    subl -n "`pwd`"
  else
    if [ -d "$1" ]; then
      subl -n "$1"
    else
      subl -a "$1"
    fi
  fi
}

sublime () {
  load_sublime_path "$@"
}


