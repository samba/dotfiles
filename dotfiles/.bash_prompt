#!/usr/bin/env bash
# Several syntax elements in this file are specifically chosen to break the
# use of this script (as is) shells other than bash. I figure I can do away
# with some of the safeguards for scripts I maintain only personally.


function prompt::color_hint () {
    # echo "TERM is ${TERM}" >&2
    case "$TERM" in
        xterm*)
            test "${COLORTERM:0:6}" = "gnome-" && \
                infocmp gnome-256color >/dev/null 2>&1 && \
                echo "gnome-256color"
            # also...
            infocmp xterm-256color >/dev/null 2>&1 && echo "xterm-256color"
            ;;
        *)
            test -z "$COLORTERM" || echo "$COLORTERM"
            echo "$TERM"
            ;;
    esac
}

function prompt::should_apply_color () {
    test -z "$PS1" && return 1  # Don't color non-interactive.
    test -z "${1:-${COLORTERM}}" && return 1
    return 0
}


function prompt::abbreviate_working_path () {

    # Initially the title should be the current directory (shortened)
    local workingpath="$(pwd | sed -E "s@${HOME}@~@; s@([^/])[^/]*/@\\1/@g;")"

    # When operating over SSH, include hostname in title
    # NOTE: this assume this script is running remotely
    test -z "$SSH_TTY" || workingpath="${HOSTNAME%%.*}:${workingpath}"

    echo $workingpath
}


# Provides ${PROMPT_COMMAND}
# Redefines PS1 as needed.
# NB: this command is executed by PROMPT_COMMAND, which provides LAST_RETURN_CODE
function prompt::command () {

    local set_status=true
    local status_message="$(prompt::abbreviate_working_path)"
    local shell_title=""


    history -a >/dev/null;  # append history file.

    # Virtual Studio Code doesn't like the status flags.
    case "${TERM_PROGRAM}" in
        vscode) set_status=false;;
    esac

    # Disable statusline if not supported
    tput hs || set_status=false;


    if test ${set_status} = true; then
        if test -n "$STY"; then
            printf "\x1B_%s\x1B\\" "${status_message}"  # screen hardstatus
            printf "\033k%s\033\\" "${status_message}"
        else
            # This is normally interpreted as the shell title, in terminal emulators
            # like xterm, iTerm2, etc
            printf "\033]0;%s\007" "${status_message}"
        fi
    fi

    # a null-title sequence for screen to interpret the live command
    test -n "$STY" && printf "\033k\033\134"

     # NB: this must exactly match screen's shelltitle command below.
    local shelltitle_prefix="> "

    # Initialize a generally compatible set of base colors & controls
    local bell='\[\a\]'
    local reset='\[\e[0m\]'
    local reverse='\e[7;m'
    local default='\[\e[39m\e[49m\]'
    local bold='\[\e[1m\]'  # TODO
    local blue='\[\e[01;34m\]'
    local yellow='\[\e[01;33m\]'
    local green='\[\e[01;32m\]'
    local red='\[\e[01;31m\]'
    local orange='\[\e[01;33m\]' # looks like yellow.
    local cyan='\[\e[01;36m\]'
    local black='\[\e[01;30m\]'
    local purple='\[\e[01;35m\]'
    local white='\[\e[01;37m\]'
    local violet='\[\e[01;35m\]'

    if tput setaf 1 >/dev/null; then
        tput sgr0 # reset now

        # The following start with a commonly compatible color code, followed
        # by a more specific color for terminals that support it. Normally
        # this should fail gracefully on older terminals.

        reset="\[$(tput sgr0)\]"
        bold="\[$(tput bold)\]"
        blue="\[$(tput setaf 4)$(tput setaf 33)\]"
        yellow="\[$(tput setaf 3)$(tput setaf 136)\]"
        green="\[$(tput setaf 2)$(tput setaf 64)\]"
        red="\[$(tput setaf 1)$(tput setaf 124)\]"
        orange="\[$(tput setaf 1)$(tput setaf 166)\]"
        cyan="\[$(tput setaf 6)$(tput setaf 37)\]"
        black="\[$(tput setaf 0)\]"
        purple="\[$(tput setaf 5)$(tput setaf 125)\]"
        white="\[$(tput setaf 7)$(tput setaf 15)\]"
        violet="\[$(tput setaf 5)$(tput setaf 61)\]"
        reverse="\[$(tput rev)\]"

    fi


    # fetch current Kubernetes context name
    local kube_context="$(which kubectl >/dev/null && kubectl config current-context 2>/dev/null)"

    # color is red if error, green otherwise
    local error="\[\e[00;\$((${LAST_RETURN_CODE} ? 31 : 36 ))m\]"

    # Git status (branch {untracked}{staged}{unstaged}{stashed})
    local gitfmt="${green}\$br${red}\$ut${orange}\$sg${blue}\$ug${violet}\$st${reset}"
    local gitstat="$(prompt::git_status "${gitfmt}")"

    declare -a parts=(
        "${bell}${error}\\\\t"           # timestamp
        "${default}\j"                   # background jobs
        "${blue}\W"                      # current directory
        "${gitstat}"                     # git context
        "${orange}${kube_context}"       # kubernetes context
        "${error}\$"             # prompt ending
    )

    local template="%b %b %b %b %b\\n%b%b"

    printf -v prompt "${template}" "${parts[@]}" "${reset}"

    export PS1="${prompt}${shelltitle_prefix}"
    export PS2="${yellow}>${reset} "
    export PS3='> ' # PS3 doesn't get expanded like 1, 2 and 4
    export PS4="${blue}+${reset} "

}



function prompt::git_status () {
    # This expects any color aspects to be embedded in the incoming template.

    local template="${1:-"\$br:\$ug\$sg\$st\$ut"}"

    # Symbols used to represent state.
    local changes_staged="+"
    local changes_unstaged="!"
    local files_untracked="?"
    local changes_stashed="\$"

    which git >/dev/null 2>/dev/null || return 1

    # It's a valid git directory, and not ".git"
    test "$(git rev-parse --is-inside-work-tree 2>/dev/null)" = "true" || return 1
    test "$(git rev-parse --is-inside-git-dir 2>/dev/null)" = "false" || return 1

    git update-index --really-refresh -q &>/dev/null

    # Produce the branch name first
    local branch="$(git symbolic-ref --quiet --short HEAD || git rev-parse --short HEAD || echo "(unknown)")"
    template="${template//\$br/${branch}}"

    # Staged changes
    if ! git diff --quiet --ignore-submodules --cached; then
        template="${template//\$sg/${changes_staged}}"
    else
        template="${template//\$sg/}"
    fi

    # Unstaged changes
    if ! git diff-files --quiet --ignore-submodules --; then
        template="${template//\$ug/${changes_unstaged}}"
    else
        template="${template//\$ug/}"
    fi

    # Untracked files
    if ! test -z "$(git ls-files --others --exclude-standard)"; then
        template="${template//\$ut/${files_untracked}}"
    else
        template="${template//\$ut/}"
    fi

    # Stashed state
    if git rev-parse --verify refs/stash &>/dev/null; then
        template="${template//\$st/${changes_stashed}}"
    else
        template="${template//\$st/}"
    fi

    echo "${template}"
    return 0
}




function wtf () {
    # these colors do not require all the bounding markers of a shell prompt.
    local reset='\e[0m'
    local blue='\e[01;34m'
    local yellow='\e[01;33m'
    local green='\e[01;32m'
    local red='\e[01;31m'
    local cyan='\e[01;36m'
    local black='\e[01;30m'
    local purple='\e[01;35m' 
    local white='\e[01;37m'
    local violet='\e[01;35m'

    local usercolor="${yellow}"
    test ${UID} -eq 0 && usercolor="${red}"

    printf "${usercolor}%s${reset}@${green}%s${reset}:${blue}%s${reset}\n" \
        "$(echo ${USER:-$(whoami)})" \
        "$(hostname -f)" \
        "$(pwd | sed "s@${HOME}@~@")" 


}


function prompt::basic () {
    printf -v PS1 '\\t \u@\h \W \j \$ ';
    export PS1;
    export PROMPT_COMMAND="";
    export GIT_PROMPT="";
}

export PROMPT_COMMAND="LAST_RETURN_CODE=\$?; [[ \$(type -t 'prompt::command') == "function" ]] &&  prompt::command"
export COLORTERM="$(prompt::color_hint | head -n 1)"


if prompt::should_apply_color "${COLORTERM}"; then
    prompt::command # run now too, to correctly export PS1 from the start.

    # Fix terminal identification as it effects color features of `tput`
    case "${TERM}" in 
        screen|xterm) # common short terminal names
        case "${COLORTERM}" in
            truecolor|*-256color) # color is supported
                # enables `tput colors` == 256
                export TERM="${TERM}-256color"
            ;;
        esac
        test "truecolor" = "${COLORTERM}" && \
            screen -X eval "at # truecolor on"
        ;;
    esac
else
     prompt::basic
fi


# Override manual title spec on first run.
# NB: keep this consistent with the shelltitle directive in .screenrc
test -n "$STY" && screen -X shelltitle '> |shell'
